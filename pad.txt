https://pnp.github.io/cli-microsoft365/cmd/outlook/mail/mail-send/


name idea: notae
https://github.com/mintty/utils
https://github.com/pkulak/matui/
look for matrix-commander-tui (package it myself? re-(ckage matrix-commander to include tui?)
https://github.com/pkulak/matui/



Key:
* 1 ### definitely using in my first iteration
* 2 ### to add once the core functionality is solid
* 3 - want to add, but need to compare to alternatives
* 4 ### nice functionality I would like to add
* 5 - definitely to use someday, but not right now
* 6 ### need to try out to see how it works
* 7 ### probably not
* 8 ### obsoleted by another plugin
* 9 ### inherently obsolete

https://www.reddit.com/r/neovim/comments/1bxmbki/when_you_want_to_use_neovim_but_dont_want_to/?share_id=8O3Yu6a-RuZst7KiMHBX4&utm_content=1&utm_medium=android_app&utm_name=androidcss&utm_source=share&utm_term=10

https://github.com/yutkat/my-neovim-pluginlist <- get recent changes

https://github.com/folke/paint.nvim for note highlighting
https://github.com/nvim-treesitter/nvim-treesitter#adding-parsers alternative for note highlighting

https://thenextweb.com/news/everything-you-need-to-know-about-finch-the-latest-programming-language-developed-by-mit

https://github.com/Dartypier/image-editor
-> https://www.tecmint.com/best-image-photo-editors-for-linux/
https://github.com/dair-ai/Prompt-Engineering-Guide https://www.promptingguide.ai/

http://elvissaravia.com/


consilium subcommand groups: declare, derive, journal, note, maintain (with aliases {} ++ [] :: ~~)

algorithmic consideration for scheduling: I should first compute a feasible schedule based on easy constraints, then follow a series of optimizations to move tasks according to score -> incremental approach is computationally faster and a brute-force search of the schedule space, and is still likely to yield very good results. Basic idea: make change if one score/metric can be improved without hurting others (or without decreasing some weighted global score), perhaps to find a pareto optimal schedule -> requires a number of metrics, i.e. score functions, which may be arbitrarily complex, but should ideally be reasonably fast to compute